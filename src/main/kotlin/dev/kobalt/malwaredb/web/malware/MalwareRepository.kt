/*
 * dev.kobalt.malwaredb
 * Copyright (C) 2022 Tom.K
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package dev.kobalt.malwaredb.web.malware

import dev.kobalt.malwaredb.web.database.DatabaseRepository
import dev.kobalt.malwaredb.web.extension.fromCsv
import dev.kobalt.malwaredb.web.extension.toLocalDate
import dev.kobalt.web.administration.extension.transaction
import dev.kobalt.web.administration.uid.Uid
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.and
import org.jetbrains.exposed.sql.select


object MalwareRepository {

    val pageTitle = "Entries"
    val pageSubtitle = "List of entries."
    val pageRoute = "entry/"
    val pageEmpty = "There are no entries."

    val database get() = DatabaseRepository.malware

    fun selectList(): List<MalwareEntity> = database.transaction {
        MalwareTable.select { MalwareTable.visible eq true }
            .orderBy(MalwareTable.title, SortOrder.ASC)
            .map { it.toMalwareEntity() }
    }

    fun selectItem(uid: Uid): MalwareEntity? = database.transaction {
        MalwareTable.select { (MalwareTable.uid eq uid) and (MalwareTable.visible eq true) }
            .singleOrNull()?.toMalwareEntity()
    }

    fun ResultRow.toMalwareEntity(): MalwareEntity {
        return MalwareEntity(
            id = this[MalwareTable.id].value,
            uid = this[MalwareTable.uid],
            title = this[MalwareTable.title],
            types = this[MalwareTable.type]?.trim()?.fromCsv()
                ?.map { it.sorted().joinToString(",") },
            sizes = this[MalwareTable.size]?.trim()?.fromCsv()
                ?.map { MalwareSizeEntity(value = it[0].toLong(), note = it.getOrNull(1)) },
            platforms = this[MalwareTable.platform]?.trim()?.fromCsv()
                ?.map { MalwarePlatformEntity(name = it[0], note = it.getOrNull(1)) },
            sourceLanguages = this[MalwareTable.sourceLanguage]?.trim()?.fromCsv()
                ?.map { MalwareSourceLanguageEntity(name = it[0], note = it.getOrNull(1)) },
            fileTypes = this[MalwareTable.fileType]?.trim()?.fromCsv()
                ?.map { MalwareFileTypeEntity(name = it[0], note = it.getOrNull(1)) },
            authors = this[MalwareTable.author]?.trim()?.fromCsv()
                ?.map { it.sorted().joinToString(",") },
            locations = this[MalwareTable.location]?.trim()?.fromCsv()
                ?.map { it.sorted().joinToString(",") },
            aliases = this[MalwareTable.alias]?.trim()?.fromCsv()
                ?.map { MalwareAliasEntity(title = it[0], author = it[1]) }?.sortedBy { it.author },
            timestamps = this[MalwareTable.timestamp]?.trim()?.fromCsv()
                ?.map { MalwareTimestampEntity(value = it[0].toLocalDate("yyyy-MM-dd"), note = it[1]) },
            links = this[MalwareTable.link]?.trim()?.fromCsv()
                ?.map { MalwareLinkEntity(title = it[0], author = it[1], link = it[2]) }?.sortedBy { it.title },
            details = this[MalwareTable.details]
        )
    }

}
